<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="重头戏">
<meta property="og:type" content="article">
<meta property="og:title" content="UCAS-Network-Lab-10~12-TCP Stack">
<meta property="og:url" content="http://example.com/2023/12/16/UCAS-Network-Lab-10~12-tcp-stack/index.html">
<meta property="og:site_name" content="&quot;The World&quot; of CLV">
<meta property="og:description" content="重头戏">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/.com//reno.png">
<meta property="og:image" content="http://example.com/.com//cwnd.png">
<meta property="article:published_time" content="2023-12-16T10:55:36.000Z">
<meta property="article:modified_time" content="2024-02-17T23:24:32.031Z">
<meta property="article:author" content="CLV">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//reno.png">


<link rel="canonical" href="http://example.com/2023/12/16/UCAS-Network-Lab-10~12-tcp-stack/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/12/16/UCAS-Network-Lab-10~12-tcp-stack/","path":"2023/12/16/UCAS-Network-Lab-10~12-tcp-stack/","title":"UCAS-Network-Lab-10~12-TCP Stack"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>UCAS-Network-Lab-10~12-TCP Stack | "The World" of CLV</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">"The World" of CLV</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="comment fa-fw"></i>guestbook</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#textlab-1-%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">1.</span> <span class="nav-text"> Lab-1. 基础协议栈\text{Lab-1. 基础协议栈}Lab-1. 基础协议栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#text1-connection"><span class="nav-number">1.1.</span> <span class="nav-text"> 1. Connection\text{1. Connection}1. Connection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text2-transmission"><span class="nav-number">1.2.</span> <span class="nav-text"> 2. Transmission\text{2. Transmission}2. Transmission</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text3-file-transmission"><span class="nav-number">1.3.</span> <span class="nav-text"> 3. File Transmission\text{3. File Transmission}3. File Transmission</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text4-disconnection"><span class="nav-number">1.4.</span> <span class="nav-text"> 4. Disconnection\text{4. Disconnection}4. Disconnection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text5-implementation"><span class="nav-number">1.5.</span> <span class="nav-text"> 5. Implementation\text{5. Implementation}5. Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#text51-socket"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 5.1. Socket\text{5.1. Socket}5.1. Socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text5-pits"><span class="nav-number">1.6.</span> <span class="nav-text"> 5. Pits\text{5. Pits}5. Pits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text6-summary"><span class="nav-number">1.7.</span> <span class="nav-text"> 6. Summary\text{6. Summary}6. Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#textlab-2-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">2.</span> <span class="nav-text"> Lab-2. 可靠传输\text{Lab-2. 可靠传输}Lab-2. 可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#text1-sender"><span class="nav-number">2.1.</span> <span class="nav-text"> 1. Sender\text{1. Sender}1. Sender</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text2-receivers"><span class="nav-number">2.2.</span> <span class="nav-text"> 2. Receivers\text{2. Receivers}2. Receivers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text3-implementation"><span class="nav-number">2.3.</span> <span class="nav-text"> 3. Implementation\text{3. Implementation}3. Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text4-pits-and-falls"><span class="nav-number">2.4.</span> <span class="nav-text"> 4. Pits and Falls\text{4. Pits and Falls}4. Pits and Falls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text5-summary"><span class="nav-number">2.5.</span> <span class="nav-text"> 5. Summary\text{5. Summary}5. Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#textlab-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text"> Lab-3. 拥塞控制\text{Lab-3. 拥塞控制}Lab-3. 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#text1-reno-newreno"><span class="nav-number">3.1.</span> <span class="nav-text"> 1. Reno &amp; NewReno\text{1. Reno \&amp; NewReno}1. Reno &amp; NewReno</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text2-implementation"><span class="nav-number">3.2.</span> <span class="nav-text"> 2. Implementation\text{2. Implementation}2. Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text3-pits-and-falls"><span class="nav-number">3.3.</span> <span class="nav-text"> 3. Pits and Falls\text{3. Pits and Falls}3. Pits and Falls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text4-result"><span class="nav-number">3.4.</span> <span class="nav-text"> 4. Result\text{4. Result}4. Result</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#text5-summary-2"><span class="nav-number">3.5.</span> <span class="nav-text"> 5. Summary\text{5. Summary}5. Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#text4-summary-for-tcp"><span class="nav-number">4.</span> <span class="nav-text"> 4. Summary for TCP\text{4. Summary for TCP}4. Summary for TCP</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CLV</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/CreeperLordVader-Iclucia-Ashina" class="github-corner" title="Fork me on GitHub!" aria-label="Fork me on GitHub!" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/16/UCAS-Network-Lab-10~12-tcp-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CLV">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=""The World" of CLV">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="UCAS-Network-Lab-10~12-TCP Stack | "The World" of CLV">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UCAS-Network-Lab-10~12-TCP Stack
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-16 18:55:36" itemprop="dateCreated datePublished" datetime="2023-12-16T18:55:36+08:00">2023-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-18 07:24:32" itemprop="dateModified" datetime="2024-02-18T07:24:32+08:00">2024-02-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>重头戏</p>
<span id="more"></span>
<p>这已经是第三阶段了，然而我连网络层实验都还没怎么做完，好在做了最基本的路由器实验，已经足够写这个部分了。</p>
<p>这三次实验的目的是，实现一个功能相对完整的 TCP/IP 协议栈。</p>
<p>回忆我们在网络层进行的实验，使得两个处于不同网络中的主机可以互相传送数据包了。</p>
<p>但是这并不够，在IP协议的基础上，TCP协议提供了可靠的全双工的传输服务，从而为更上层的应用层打下了基础。</p>
<p>个人认为，这三次实验就是整个实验课的最高潮了，前面所有的积累都是为了这三个实验上一气呵成打造相对完整的<code>TCP</code>协议栈，打下网络协议栈的最后一块砖。</p>
<h1 id="textlab-1-基础协议栈"><a class="markdownIt-Anchor" href="#textlab-1-基础协议栈"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Lab-1. 基础协议栈</mtext></mrow><annotation encoding="application/x-tex">\text{Lab-1. 基础协议栈}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Lab-1. </span><span class="mord cjk_fallback">基础协议栈</span></span></span></span></span></h1>
<p>本次实验不考虑丢包和拥塞控制，只要求实现最基本的传输。</p>
<h2 id="text1-connection"><a class="markdownIt-Anchor" href="#text1-connection"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>1. Connection</mtext></mrow><annotation encoding="application/x-tex">\text{1. Connection}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">1. Connection</span></span></span></span></span></h2>
<p>TCP的连接建立部分，服务器<code>listen</code>和<code>accept</code>，监听并且接受客户端通过<code>connect</code>发起的连接建立请求，从而建立起一个<code>TCP</code>套接字，维护连接的状态。</p>
<p>这里有如下几步：</p>
<ol>
<li>
<p>服务器需要一个父套接字持续监听请求</p>
</li>
<li>
<p>客户端发送<code>SYN</code>，服务器接收到之后，创建一个子套接字用于与该客户端进行持续连接，发送<code>SYN-ACK</code>，同时很重要的一步是将该套接字的信息进行哈希，以便后续能够查找到。</p>
</li>
<li>
<p>客户端接收到<code>SYN-ACK</code>之后，发送<code>ACK</code>，连接建立完成</p>
</li>
</ol>
<p>这个过程中，两方都会随机一个数作为序列号的“起点”，并且在<code>SYN</code>和<code>ACK</code>中发送给对方，用于后续的数据包的序列号。</p>
<h2 id="text2-transmission"><a class="markdownIt-Anchor" href="#text2-transmission"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>2. Transmission</mtext></mrow><annotation encoding="application/x-tex">\text{2. Transmission}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">2. Transmission</span></span></span></span></span></h2>
<p>这里涉及到各种<code>seq</code>，<code>ack</code>等字段的更新，如果完全分情况讨论非常复杂，仔细理解可以总结出一定的规律如下：</p>
<ol>
<li>
<p>在发送带<code>SYN</code>，<code>FIN</code>或者数据的包时，都需要更新<code>seq</code>字段，可以理解为“主动发送数据/控制信息的序列号”</p>
</li>
<li>
<p>在接收到数据包时，如果是新数据则需要更新<code>ack</code>字段并回复，这也是<code>ack</code>的字面意义，“告知收到”</p>
</li>
</ol>
<p>然而最麻烦的还是滑动窗口的更新，在本次实验中，由于我们暂不考虑丢包等等，这个问题还能得到些简化，基本上就是发过来的包都是新的，把滑动窗口的左边界直接更新到<code>ack</code>的值即可。</p>
<p>由于这实验中，都是很小很小的数据包，所以完全不用考虑缓冲区的问题，直接发送就行。</p>
<h2 id="text3-file-transmission"><a class="markdownIt-Anchor" href="#text3-file-transmission"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>3. File Transmission</mtext></mrow><annotation encoding="application/x-tex">\text{3. File Transmission}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">3. File Transmission</span></span></span></span></span></h2>
<p>大文件传输和小消息的重大区别就是缓冲区不够用了，如果一个一个包发送会极其慢，无法满足时限要求，因此我们必须一次性大批量地连续发送数据。</p>
<p>这就会导致一个情况，也就是传输数据的速度很有可能快于对方接受数据的速度。滑动窗口最大的大小和留给上层应用的缓冲区容量是一致的。我们发送的数据首先会存在对方的缓冲区中，并不一定立即得到处理，也不一定立即能回复<code>ack</code>。</p>
<p>因此为了防止发送的数据溢出对方缓冲区，发送方就需要通过滑动窗口来控制发送的数据量。</p>
<p>具体而言， 在接收方从缓冲区中取出数据并且处理之后，缓冲区空间增加，相应的能处理的数据量也增加了，此时向发送方回复的包中，不止含有新的<code>ack</code>，同时也会告知发送方更新后的接收窗口大小，发送方在接收到之后，便可以根据该字段来调整发送窗口的大小。发送方的滑动窗口只会在主动发送数据包和收到<code>ack</code>时更新。</p>
<p>每发送一个包，发送方的<code>snd_nxt</code>都会增加，同时滑动窗口会减少相应的长度，因为没有收到对方的<code>ack</code>，就应该认为数据还在缓冲区中，能够发送的数据量就会减少。</p>
<h2 id="text4-disconnection"><a class="markdownIt-Anchor" href="#text4-disconnection"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>4. Disconnection</mtext></mrow><annotation encoding="application/x-tex">\text{4. Disconnection}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">4. Disconnection</span></span></span></span></span></h2>
<p>TCP的连接断开是一个比较复杂的过程，因为需要保证数据的完整性，所以需要经过四次握手。</p>
<ol>
<li>
<p>主动关闭方发送<code>FIN</code>，并且进入<code>FIN_WAIT_1</code>状态</p>
</li>
<li>
<p>被动关闭方接收到<code>FIN</code>，发送<code>ACK</code>，并且进入<code>CLOSE_WAIT</code>状态</p>
</li>
<li>
<p>被动关闭方发送<code>FIN</code>，并且进入<code>LAST_ACK</code>状态</p>
</li>
<li>
<p>主动关闭方接收到<code>FIN</code>，发送<code>ACK</code>，并且进入<code>TIME_WAIT</code>状态</p>
</li>
</ol>
<p>在<code>TIME_WAIT</code>状态持续一段时间之后，连接才会真正断开，这需要通过一个定时器实现。实际上的定时器会有两种，这里使用的是其中的一种，另一种用于超时重传，在下面的可靠传输部分会详细介绍。</p>
<h2 id="text5-implementation"><a class="markdownIt-Anchor" href="#text5-implementation"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>5. Implementation</mtext></mrow><annotation encoding="application/x-tex">\text{5. Implementation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">5. Implementation</span></span></span></span></span></h2>
<h3 id="text51-socket"><a class="markdownIt-Anchor" href="#text51-socket"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>5.1. Socket</mtext></mrow><annotation encoding="application/x-tex">\text{5.1. Socket}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">5.1. Socket</span></span></span></span></span></h3>
<p>首先看顶层的socket实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_bind</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> sock_addr* skaddr)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">  <span class="comment">// omit the ip address, and only bind the port</span></span><br><span class="line">  err = tcp_sock_set_sport(tsk, ntohs(skaddr-&gt;port));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bind的实现还是非常简单的，只需要设置端口号即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// connect to the remote tcp sock specified by skaddr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">XXX:</span> skaddr here contains network-order variables</span></span><br><span class="line"><span class="comment">// 1. initialize the four key tuple (sip, sport, dip, dport);</span></span><br><span class="line"><span class="comment">// 2. hash the tcp sock into bind_table;</span></span><br><span class="line"><span class="comment">// 3. send SYN packet, switch to TCP_SYN_SENT state, wait for the incoming</span></span><br><span class="line"><span class="comment">//    SYN packet by sleep on wait_connect;</span></span><br><span class="line"><span class="comment">// 4. if the SYN packet of the peer arrives, this function is notified, which</span></span><br><span class="line"><span class="comment">//    means the connection is established.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_connect</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> sock_addr* skaddr)</span> &#123;</span><br><span class="line">  <span class="comment">// initialize the four key tuple (sip, sport, dip, dport)</span></span><br><span class="line">  tsk-&gt;sk_sip = ((<span class="type">iface_info_t</span>*)(instance-&gt;iface_list.next))-&gt;ip;</span><br><span class="line">  tsk-&gt;sk_sport = tcp_get_port();</span><br><span class="line">  tsk-&gt;sk_dip = ntohl(skaddr-&gt;ip);</span><br><span class="line">  tsk-&gt;sk_dport = ntohs(skaddr-&gt;port);</span><br><span class="line">  <span class="comment">// hash the tcp sock into bind_table</span></span><br><span class="line">  tcp_bind_hash(tsk);</span><br><span class="line">  <span class="comment">// send SYN packet, switch to TCP_SYN_SENT state, wait for the incoming</span></span><br><span class="line">  <span class="comment">// SYN packet by sleep on wait_connect</span></span><br><span class="line">  tcp_set_state(tsk, TCP_SYN_SENT);</span><br><span class="line">  tcp_hash(tsk);</span><br><span class="line">  tcp_send_control_packet(tsk, TCP_SYN);</span><br><span class="line">  sleep_on(tsk-&gt;wait_connect);</span><br><span class="line">  <span class="comment">// if the SYN packet of the peer arrives, this function is notified, which</span></span><br><span class="line">  <span class="comment">// means the connection is established</span></span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;state == TCP_ESTABLISHED)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connect的实现如前所述，客户端方需要主动发送<code>SYN</code>，切换自身状态，并且等待对方的<code>SYN-ACK</code>，这里通过<code>sleep_on</code>来实现等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set backlog (the maximum number of pending connection requst), switch the</span></span><br><span class="line"><span class="comment">// TCP_STATE, and hash the tcp sock into listen_table</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_listen</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="type">int</span> backlog)</span> &#123;</span><br><span class="line">  tsk-&gt;backlog = backlog;</span><br><span class="line"></span><br><span class="line">  tcp_set_state(tsk, TCP_LISTEN);</span><br><span class="line">  tcp_hash(tsk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>listen初始化了服务器的状态，即创建一个父套接字，用于持续监听请求，同时设置了最大的连接请求队列长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// if accept_queue is not emtpy, pop the first tcp sock and accept it,</span></span><br><span class="line"><span class="comment">// otherwise, sleep on the wait_accept for the incoming connection requests</span></span><br><span class="line"><span class="keyword">struct</span> tcp_sock* <span class="title function_">tcp_sock_accept</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (list_empty(&amp;tsk-&gt;accept_queue)) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;tcp sock accept queue is empty, sleep on wait_accept.&quot;</span>);</span><br><span class="line">    sleep_on(tsk-&gt;wait_accept);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span>* <span class="title">socket</span> =</span> tcp_sock_accept_dequeue(tsk);</span><br><span class="line">  <span class="keyword">return</span> socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于<code>accept</code>来说，我们认为协议栈会把发送过来的连接请求放到一个队列中，如果队列为空则需要等待，否则直接返回队列中的第一个套接字，这就是连接到服务器的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// close the tcp sock, by releasing the resources, sending FIN/RST packet</span></span><br><span class="line"><span class="comment">// to the peer, switching TCP_STATE to closed</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_sock_close</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk)</span> &#123;</span><br><span class="line">  <span class="comment">// send FIN packet</span></span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;closing tcp sock.&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> (tsk-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">      tcp_send_control_packet(tsk, TCP_FIN | TCP_ACK);</span><br><span class="line">      tcp_set_state(tsk, TCP_FIN_WAIT_1);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">      tcp_send_control_packet(tsk, TCP_FIN | TCP_ACK);</span><br><span class="line">      tcp_set_state(tsk, TCP_LAST_ACK);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">      tcp_send_control_packet(tsk, TCP_RST);</span><br><span class="line">      tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">      wake_up(tsk-&gt;wait_connect);</span><br><span class="line">      wake_up(tsk-&gt;wait_recv);</span><br><span class="line">      wake_up(tsk-&gt;wait_send);</span><br><span class="line">      wake_up(tsk-&gt;wait_accept);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;tcp sock state error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个关闭基本上是按照四次挥手的过程来的，根据不同的状态发送不同的信息并设置新的状态，需要注意的是关闭的时候需要唤醒所有等待的条件来彻底释放资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read data from tcp buffer</span></span><br><span class="line"><span class="comment">// returns: 0 if reach the end of file, or the connection is closed</span></span><br><span class="line"><span class="comment">// -1 if error</span></span><br><span class="line"><span class="comment">// otherwise, return the number of bytes read</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_read</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="type">char</span>* buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> read_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (is_buffer_empty(tsk-&gt;rcv_buf) &amp;&amp; tsk-&gt;state == TCP_ESTABLISHED) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;sleep on recv&quot;</span>);</span><br><span class="line">    sleep_on(tsk-&gt;wait_recv);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;wake up from recv&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;state == TCP_CLOSE_WAIT &amp;&amp; ring_buffer_empty(tsk-&gt;rcv_buf)) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> newly_read_len = read_ring_buffer(tsk-&gt;rcv_buf, buf, len);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;read %d bytes from ring buffer&quot;</span>, newly_read_len);</span><br><span class="line">  read_len += newly_read_len;</span><br><span class="line">  tsk-&gt;rcv_wnd = ring_buffer_free(tsk-&gt;rcv_buf);</span><br><span class="line">  tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> read_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取数据的时候，需要注意的是，如果缓冲区为空，需要等待，这里通过<code>sleep_on</code>实现。读取完数据之后，需要更新接收窗口的大小，并且发送<code>ack</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// returns -1 if error</span></span><br><span class="line"><span class="comment">// otherwise, return the number of bytes written</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_write</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="type">char</span>* buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sent_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (sent_len &lt; len) &#123;</span><br><span class="line">    <span class="keyword">while</span> (tsk-&gt;snd_wnd == <span class="number">0</span> &amp;&amp; tsk-&gt;state == TCP_ESTABLISHED)</span><br><span class="line">      sleep_on(tsk-&gt;wait_send);</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;state == TCP_CLOSED) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> send_len = min(tsk-&gt;snd_una + tsk-&gt;snd_wnd - tsk-&gt;snd_nxt, len - sent_len);</span><br><span class="line">    send_len = min(</span><br><span class="line">        send_len, <span class="number">1514</span> - ETHER_HDR_SIZE - IP_BASE_HDR_SIZE - TCP_BASE_HDR_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!send_len) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">char</span>* packet_buf = <span class="built_in">malloc</span>(send_len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE +</span><br><span class="line">                              TCP_BASE_HDR_SIZE);</span><br><span class="line">    <span class="type">char</span>* data =</span><br><span class="line">        packet_buf + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, buf + sent_len, send_len);</span><br><span class="line">    tcp_send_packet(</span><br><span class="line">        tsk, packet_buf,</span><br><span class="line">        send_len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE);</span><br><span class="line">    sent_len += send_len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写入数据的时候，需要注意的是，如果发送窗口为0，需要等待，这里通过<code>sleep_on</code>实现。然后需要非常仔细地计算发送数据的长度，确保我们发送的数据包不会超过一个包的最大长度。如果一次发送不完，需要循环发送。</p>
<p>和以前一样，发送一个包会释放其内存，所以需要拷贝一份发送。</p>
<p>接下来是协议栈本身的实现。首先是实现一个函数专门用于确认收到的包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ack_data_packet</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> tcp_cb* cb,</span></span><br><span class="line"><span class="params">                            <span class="type">char</span>* packet)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* data = packet + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;ack data packet, seq: %d, ack: %d&quot;</span>, cb-&gt;seq, cb-&gt;ack);</span><br><span class="line">  tcp_update_window_safe(tsk, cb);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> data_len = cb-&gt;pl_len;</span><br><span class="line">  <span class="type">int</span> offset = tsk-&gt;rcv_nxt - cb-&gt;seq;</span><br><span class="line">  data_len -= offset;</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;write data to rcv_buf, offset: %d, data_len: %d&quot;</span>, offset,</span><br><span class="line">        data_len);</span><br><span class="line">    <span class="type">bool</span> old_empty = ring_buffer_empty(tsk-&gt;rcv_buf);</span><br><span class="line">    write_ring_buffer(tsk-&gt;rcv_buf, data + offset, data_len);</span><br><span class="line">    tsk-&gt;rcv_wnd = ring_buffer_free(tsk-&gt;rcv_buf);</span><br><span class="line">    <span class="keyword">if</span> (old_empty &amp;&amp; !ring_buffer_empty(tsk-&gt;rcv_buf)) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;buffer is not empty, wake up receiving&quot;</span>);</span><br><span class="line">      wake_up(tsk-&gt;wait_recv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;write data to rcv_buf succeeded, rcv_wnd: %d&quot;</span>, tsk-&gt;rcv_wnd);</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    pthread_mutex_unlock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要记得一点，缓存为空是应用线程睡眠的条件，因此破坏该条件时也要唤醒应用线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_process</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> tcp_cb* cb, <span class="type">char</span>* packet)</span> &#123;</span><br><span class="line">  assert(tsk);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG,</span><br><span class="line">      <span class="string">&quot;handle tcp packet: flags = %s, socket state = %s, ack = %d, seq = %d, rwnd = %d&quot;</span>,</span><br><span class="line">      tcp_flags_str(cb-&gt;flags), tcp_state_str[tsk-&gt;state], cb-&gt;ack, cb-&gt;seq, cb-&gt;rwnd);</span><br><span class="line">  <span class="keyword">if</span> (cb-&gt;flags &amp; TCP_RST) &#123;</span><br><span class="line">    tcp_sock_close(tsk);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if ((cb-&gt;flags &amp; TCP_ACK) &amp;&amp; (cb-&gt;flags &amp; TCP_SYN))</span></span><br><span class="line">  <span class="comment">//   tcp_handle_ack_syn(tsk, cb, packet);</span></span><br><span class="line">  <span class="keyword">if</span> (cb-&gt;flags &amp; TCP_ACK) tcp_handle_ack(tsk, cb, packet);</span><br><span class="line">  <span class="keyword">if</span> (cb-&gt;flags &amp; TCP_SYN) tcp_handle_syn(tsk, cb, packet);</span><br><span class="line">  <span class="keyword">if</span> (cb-&gt;flags &amp; TCP_FIN) tcp_handle_fin(tsk, cb, packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据收到的包的类型，调用不同的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_handle_ack</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> tcp_cb* cb,</span></span><br><span class="line"><span class="params">                           <span class="type">char</span>* packet)</span> &#123;</span><br><span class="line">  assert(cb-&gt;flags &amp; TCP_ACK);</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;state == TCP_SYN_RECV) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tcp_set_state(tsk, TCP_ESTABLISHED);</span><br><span class="line">      tcp_hash(tsk);</span><br><span class="line">      <span class="comment">// add to the accept queue of parent socket</span></span><br><span class="line">      tcp_sock_accept_enqueue(tsk);</span><br><span class="line">      wake_up(tsk-&gt;parent-&gt;wait_accept);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_SYN_SENT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">      tcp_update_window(tsk, cb);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_ESTABLISHED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_tcp_seq_valid(tsk, cb)) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;Received valid packet, seq: %d, ack: %d&quot;</span>, cb-&gt;seq, cb-&gt;ack);</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;Current receiving window from %d to %d&quot;</span>, tsk-&gt;rcv_nxt,</span><br><span class="line">          tsk-&gt;rcv_nxt + tsk-&gt;rcv_wnd);</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      ack_data_packet(tsk, cb, packet);</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;Current receiving window from %d to %d&quot;</span>, tsk-&gt;rcv_nxt,</span><br><span class="line">          tsk-&gt;rcv_nxt + tsk-&gt;rcv_wnd);</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;Current sending window from %d to %d&quot;</span>, tsk-&gt;snd_una,</span><br><span class="line">          tsk-&gt;snd_una + tsk-&gt;snd_wnd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received packet with invalid seq, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_FIN_WAIT_1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tcp_set_state(tsk, TCP_FIN_WAIT_2);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_FIN_WAIT_2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_tcp_seq_valid(tsk, cb)) &#123;</span><br><span class="line">      tcp_update_window_safe(tsk, cb);</span><br><span class="line">      tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">      wake_up(tsk-&gt;wait_send);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received packet with invalid seq, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_LAST_ACK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_TIME_WAIT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_CLOSING) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;ack == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">      tsk-&gt;snd_una = cb-&gt;ack;</span><br><span class="line">      tcp_set_state(tsk, TCP_TIME_WAIT);</span><br><span class="line">      tcp_set_timewait_timer(tsk);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在不同的状态下，收到<code>ack</code>的处理是不同的。除了几乎每个状态都需要的切换状态以外，在<code>RECV_SYNC</code>状态下收到<code>ack</code>我们需要初始化一个新的套接字，而在<code>ESTABLISHED</code>状态下收到<code>ack</code>我们需要确认收到的包。<code>TIME_WAIT</code>状态下收到<code>ack</code>则需要开启定时器准备关闭连接。由于<code>ack</code>包是可能承载数据的，我们计算一个<code>ack</code>包中实际数据的长度，根据其是否为0来判断是否为数据包。</p>
<p>接下来是处理其他类型的包，比如<code>SYN</code>，<code>FIN</code>等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_handle_syn</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> tcp_cb* cb,</span></span><br><span class="line"><span class="params">                           <span class="type">char</span>* packet)</span> &#123;</span><br><span class="line">  assert(cb-&gt;flags &amp; TCP_SYN);</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;state == TCP_LISTEN) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span>* <span class="title">csk</span> =</span> alloc_tcp_sock();</span><br><span class="line">    csk-&gt;sk_sip = cb-&gt;daddr;</span><br><span class="line">    csk-&gt;sk_sport = cb-&gt;dport;</span><br><span class="line">    csk-&gt;sk_dip = cb-&gt;saddr;</span><br><span class="line">    csk-&gt;sk_dport = cb-&gt;sport;</span><br><span class="line">    csk-&gt;parent = tsk;</span><br><span class="line">    csk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    csk-&gt;iss = tcp_new_iss();</span><br><span class="line">    csk-&gt;snd_nxt = csk-&gt;iss;</span><br><span class="line">    csk-&gt;snd_una = csk-&gt;iss;</span><br><span class="line">    csk-&gt;rcv_wnd = TCP_DEFAULT_WINDOW;</span><br><span class="line">    csk-&gt;snd_wnd = cb-&gt;rwnd;</span><br><span class="line">    tcp_set_state(csk, TCP_SYN_RECV);</span><br><span class="line">    tcp_hash(csk);</span><br><span class="line">    tcp_send_control_packet(csk, TCP_SYN | TCP_ACK);</span><br><span class="line">    list_add_tail(&amp;csk-&gt;<span class="built_in">list</span>, &amp;tsk-&gt;listen_queue);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_SYN_SENT) &#123;</span><br><span class="line">    tcp_set_state(tsk, TCP_ESTABLISHED);</span><br><span class="line">    tcp_hash(tsk);</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    wake_up(tsk-&gt;wait_connect);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面对对方发来的<code>SYN</code>包，目前我们只需要考虑两种可能性， 一种是服务器收到<code>SYN</code>包，这时候需要创建一个新的套接字，然后发送<code>SYN-ACK</code>包，另一种是客户端收到<code>SYN-ACK</code>包，这时候需要确认收到，并且唤醒等待的条件，并且回复<code>ACK</code>包。</p>
<p>最后是考虑<code>FIN</code>包，其实<code>FIN</code>和<code>SYN</code>处理都是比较简单的，因为这两种包主要出现于连接的建立和断开阶段，用处都比较特定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_handle_fin</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="keyword">struct</span> tcp_cb* cb,</span></span><br><span class="line"><span class="params">                           <span class="type">char</span>* packet)</span> &#123;</span><br><span class="line">  assert(cb-&gt;flags &amp; TCP_FIN);</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;state == TCP_ESTABLISHED) &#123;</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    tcp_set_state(tsk, TCP_CLOSE_WAIT);</span><br><span class="line">    wake_up(tsk-&gt;wait_connect);</span><br><span class="line">    wake_up(tsk-&gt;wait_recv);</span><br><span class="line">    wake_up(tsk-&gt;wait_send);</span><br><span class="line">    wake_up(tsk-&gt;wait_accept);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_FIN_WAIT_1) &#123;</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    tcp_set_state(tsk, TCP_CLOSING);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_FIN_WAIT_2) &#123;</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    tcp_set_state(tsk, TCP_TIME_WAIT);</span><br><span class="line">    tcp_set_timewait_timer(tsk);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsk-&gt;state == TCP_LAST_ACK) &#123;</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">    tcp_unhash(tsk);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;received unexpected packet, drop it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比较特殊的地方就是注意一个<code>unhash</code>和一个设置定时器。</p>
<p>最后本次实验使用到的一个定时器，用于处理<code>TIME_WAIT</code>状态下的连接关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_scan_timer_list</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">pos</span>, *<span class="title">q</span>;</span></span><br><span class="line">  <span class="comment">// iterate over the timer_list</span></span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  list_for_each_entry_safe(pos, q, &amp;timer_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">// decrease the timeout value</span></span><br><span class="line">    pos-&gt;timeout -= TCP_TIMER_SCAN_INTERVAL;</span><br><span class="line">    <span class="keyword">if</span> (pos-&gt;timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// if timeout is less or equal to zero, the timer has expired</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tsk</span> =</span> timewait_to_tcp_sock(pos);</span><br><span class="line">      <span class="keyword">if</span> (tsk-&gt;state == TCP_TIME_WAIT) &#123;</span><br><span class="line">        <span class="comment">// if the tcp_sock is in TIME_WAIT state for 2*MSL, release it</span></span><br><span class="line">        tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">        tcp_unhash(tsk);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// remove the timer from the timer_list</span></span><br><span class="line">      list_delete_entry(&amp;pos-&gt;<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the timewait timer of a tcp sock, by adding the timer into timer_list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_set_timewait_timer</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">timewait_timer</span> =</span> &amp;tsk-&gt;timewait;</span><br><span class="line">  timewait_timer-&gt;type = <span class="number">0</span>;</span><br><span class="line">  timewait_timer-&gt;timeout = TCP_TIMEWAIT_TIMEOUT;</span><br><span class="line">  timewait_timer-&gt;enable = <span class="number">1</span>;</span><br><span class="line">  list_add_tail(&amp;timewait_timer-&gt;<span class="built_in">list</span>, &amp;timer_list);</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们之前没有提到计时器列表的老化操作，不过对于本次实验来说倒也没啥必要，因为就一个套接字，自然也就只有一个定时器，老不老化都比较无所谓的那种。</p>
<h2 id="text5-pits"><a class="markdownIt-Anchor" href="#text5-pits"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>5. Pits</mtext></mrow><annotation encoding="application/x-tex">\text{5. Pits}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">5. Pits</span></span></span></span></span></h2>
<p>一样的，作为TCP协议栈的开山之作，本次实验码量依然不小，而且还是有大量的坑。</p>
<ol>
<li>
<p>不知道是我的实现上有问题还是别的问题，<code>wake_up</code>有时可能会出现假唤醒，所以注意循环检查条件。</p>
</li>
<li>
<p>环形缓存一定要注意操作的原子性，为保证线程安全，需要加锁。但是锁一定要放在<code>ring_buffer</code>结构体里数据区的前面…否则初始化ring_buffer的时候一个内存分配就给把锁给覆盖了。</p>
</li>
<li>
<p>窗口更新什么的细节就不说了，这个真的只能靠自己慢慢去仔细覆盖每种情况的所有操作。我能想到的最暴力的办法就是直接抓reference给他彻底看明白并且对上。</p>
</li>
<li>
<p>由于没有实现丢包机制，绝不可一次性大量发送数据包，这样会导致<code>bufferfloat</code>进而导致丢包，导致两方传输出现异常。我的策略是发送一定长度就睡眠一会儿。</p>
</li>
<li>
<p>性能是个很关键的问题，本次实验在文件传输上有着<code>10</code>秒的时间限制，因此不能睡得时间太长，也不能让每两次睡眠之间的发送长度太短。</p>
</li>
</ol>
<h2 id="text6-summary"><a class="markdownIt-Anchor" href="#text6-summary"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>6. Summary</mtext></mrow><annotation encoding="application/x-tex">\text{6. Summary}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">6. Summary</span></span></span></span></span></h2>
<p>本次实验实现了一个基本的TCP协议栈，暂时不包括丢包和拥塞控制，但是已经能够实现基本的连接建立，数据传输和连接断开。后续的实验都将在这个基础上进行。</p>
<h1 id="textlab-2-可靠传输"><a class="markdownIt-Anchor" href="#textlab-2-可靠传输"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Lab-2. 可靠传输</mtext></mrow><annotation encoding="application/x-tex">\text{Lab-2. 可靠传输}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Lab-2. </span><span class="mord cjk_fallback">可靠传输</span></span></span></span></span></h1>
<p>实际网络中，丢包是难以避免的，所以我们需要实现可靠传输，这就需要我们对于丢包进行检测，并且在适当的时间重新发送丢失的数据包。</p>
<p>这里最主要的模块有三个：重传定时器，发送包队列和乱序包缓冲。</p>
<h2 id="text1-sender"><a class="markdownIt-Anchor" href="#text1-sender"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>1. Sender</mtext></mrow><annotation encoding="application/x-tex">\text{1. Sender}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">1. Sender</span></span></span></span></span></h2>
<p>对于发送方而言，由于可能存在重新传输数据包的情况，所以传完一个包以后不能就把它丢了，还得先缓存起来，等到收到相应的<code>ack</code>时再释放。</p>
<p>控制重传的大头就是重传定时器，当发送一个新的包时，如果定时器没有启动则需要启动定时器，在收到一个新的<code>ack</code>时则需要重置定时器。如果定时器超时则需要从发送队列中取出队头的包重新发送。</p>
<p>如果重复性地丢包，对于一个包我们会重传至多三次，每次的超时时间都会加倍，如果超过三次超时那大概是连不上了，发送<code>RST</code>包断开连接。</p>
<h2 id="text2-receivers"><a class="markdownIt-Anchor" href="#text2-receivers"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>2. Receivers</mtext></mrow><annotation encoding="application/x-tex">\text{2. Receivers}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">2. Receivers</span></span></span></span></span></h2>
<p>一旦发生丢包，接收方收到的包就会出现乱序的情况，也就不能按顺序直接填入缓冲区了，这就需要一个乱序包缓冲。用于将<code>seq</code>超过当前<code>rcv_nxt</code>的包全部存起来，等到缺失的包到来时再从该缓冲中按顺序依次<code>ack</code>数据包并且填入缓冲区。当我们收到一个新的包并且更新<code>ack</code>的时候，便可以把乱序缓冲中可以<code>ack</code>的包给<code>ack</code>掉。</p>
<p>在本次实验中，我采用了非常暴力的方式管理乱序缓冲，用一个链表存储并且插入时按顺序保持有序，虽然很慢，但是考虑到丢包的情形并不多，这不会严重损害性能。</p>
<h2 id="text3-implementation"><a class="markdownIt-Anchor" href="#text3-implementation"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>3. Implementation</mtext></mrow><annotation encoding="application/x-tex">\text{3. Implementation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">3. Implementation</span></span></span></span></span></h2>
<p>有三个重要的新模块，重传定时器，发送包队列和乱序包缓冲。</p>
<p>首先看乱序包缓冲的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ack_ofo_packets</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!list_empty(&amp;tsk-&gt;rcv_ofo_buf)) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_ofo_packet</span> *<span class="title">ofo_packet_iter</span> =</span></span><br><span class="line">        list_entry(tsk-&gt;rcv_ofo_buf.next, <span class="keyword">struct</span> tcp_ofo_packet, <span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (ofo_packet_iter-&gt;cb.seq &gt; tsk-&gt;rcv_nxt)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ofo_packet_iter-&gt;cb.seq_end &gt;= tsk-&gt;rcv_nxt) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;ack ofo packet, seq: %d, ack: %d&quot;</span>, ofo_packet_iter-&gt;cb.seq,</span><br><span class="line">          ofo_packet_iter-&gt;cb.ack);</span><br><span class="line">      ack_data_packet(tsk, &amp;ofo_packet_iter-&gt;cb, ofo_packet_iter-&gt;packet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_ofo_packet</span> *<span class="title">ofo_packet_iter_q</span> =</span> ofo_packet_iter;</span><br><span class="line">    ofo_packet_iter =</span><br><span class="line">        list_entry(ofo_packet_iter-&gt;<span class="built_in">list</span>.next, <span class="keyword">struct</span> tcp_ofo_packet, <span class="built_in">list</span>);</span><br><span class="line">    list_delete_entry(&amp;ofo_packet_iter_q-&gt;<span class="built_in">list</span>);</span><br><span class="line">    free_ofo_packet(ofo_packet_iter_q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pend_ofo_packet</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, <span class="keyword">struct</span> tcp_cb *cb,</span></span><br><span class="line"><span class="params">                            <span class="type">char</span> *packet)</span> &#123;</span><br><span class="line">  assert(cb-&gt;seq &gt; tsk-&gt;rcv_nxt);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;pend packet, seq: %d, ack: %d&quot;</span>, cb-&gt;seq, cb-&gt;ack);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_ofo_packet</span> *<span class="title">ofo_packet</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_ofo_packet));</span><br><span class="line">  <span class="type">int</span> packet_len =</span><br><span class="line">      cb-&gt;pl_len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">  ofo_packet-&gt;packet = <span class="built_in">malloc</span>(packet_len);</span><br><span class="line">  <span class="built_in">memcpy</span>(ofo_packet-&gt;packet, packet, packet_len);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;ofo_packet-&gt;cb, cb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcp_cb));</span><br><span class="line">  insert_ofo_packet(ofo_packet, &amp;tsk-&gt;rcv_ofo_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没啥好说的，就一个有序的链表，插入时保持有序，一旦<code>snd_una</code>发生更新，都需要从头开始顺序查一遍列表，把可以<code>ack</code>的包<code>ack</code>掉。</p>
<p>接下来是发送缓存的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_send_buffer</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, <span class="keyword">struct</span> tcp_cb *cb)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;send_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pending_packet</span> *<span class="title">pos</span>, *<span class="title">q</span>;</span></span><br><span class="line">  list_for_each_entry_safe(pos, q, &amp;tsk-&gt;send_buf, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less_than_32b(cb-&gt;ack, pos-&gt;seq_end))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    list_delete_entry(&amp;pos-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">free</span>(pos-&gt;packet);</span><br><span class="line">    <span class="built_in">free</span>(pos);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;send_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也是一个道理，收到<code>ack</code>之后，把<code>ack</code>掉的包从发送缓存中删除。</p>
<p>同时需要对几个发送的函数也稍作修改，以<code>tcp_send_control_packet</code>为例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_send_control_packet</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, u8 flags)</span> &#123;</span><br><span class="line">  assert(tsk-&gt;retrans_timer.type == <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pkt_size = ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">  <span class="type">char</span> *packet = <span class="built_in">malloc</span>(pkt_size);</span><br><span class="line">  <span class="keyword">if</span> (!packet) &#123;</span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;malloc tcp control packet failed.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span> =</span> packet_to_ip_hdr(packet);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcp</span> =</span> (<span class="keyword">struct</span> tcphdr *)((<span class="type">char</span> *)ip + IP_BASE_HDR_SIZE);</span><br><span class="line"></span><br><span class="line">  u16 tot_len = IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line"></span><br><span class="line">  ip_init_hdr(ip, tsk-&gt;sk_sip, tsk-&gt;sk_dip, tot_len, IPPROTO_TCP);</span><br><span class="line">  tcp_init_hdr(tcp, tsk-&gt;sk_sport, tsk-&gt;sk_dport, tsk-&gt;snd_nxt, tsk-&gt;rcv_nxt,</span><br><span class="line">               flags, tsk-&gt;rcv_wnd);</span><br><span class="line">  tcp-&gt;checksum = tcp_checksum(ip, tcp);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;send control packet, flags: %s, seq: %d, ack: %d, rwnd: %d&quot;</span>,</span><br><span class="line">      tcp_flags_str(flags), tsk-&gt;snd_nxt, tsk-&gt;rcv_nxt, tsk-&gt;rcv_wnd);</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; (TCP_SYN | TCP_FIN)) &#123;</span><br><span class="line">    insert_control_send_buffer(tsk, packet, pkt_size);</span><br><span class="line">    tsk-&gt;snd_nxt += <span class="number">1</span>;</span><br><span class="line">    tcp_set_retrans_timer(tsk);</span><br><span class="line">  &#125;</span><br><span class="line">  ip_send_packet(packet, pkt_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是“会导致<code>seq</code>增大的包”，或者说是我们“主动发送”的包，需要更新<code>seq</code>，将其插入发送缓存，并且设置重传定时器。</p>
<p>重传定时器的实现如下，一定要注意的是，重传定时器维护的是一段数据包的超时情况，这个维护直到发送的包全部被<code>ack</code>或者因为丢包触发超时而终止，而不是说每发一个包都要维护一个重传定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_set_retrans_timer</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">retrans_timer</span> =</span> &amp;tsk-&gt;retrans_timer;</span><br><span class="line">  assert(retrans_timer-&gt;type == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (retrans_timer-&gt;enable) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;set retrans timer&quot;</span>);</span><br><span class="line">  retrans_timer-&gt;enable = <span class="number">1</span>;</span><br><span class="line">  retrans_timer-&gt;timeout = TCP_RETRANS_INTERVAL_INITIAL;</span><br><span class="line">  list_add_tail(&amp;retrans_timer-&gt;<span class="built_in">list</span>, &amp;timer_list);</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_try_update_retrans_timer</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">retrans_timer</span> =</span> &amp;tsk-&gt;retrans_timer;</span><br><span class="line">  assert(retrans_timer-&gt;type == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (retrans_timer-&gt;enable == <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;try update retrans timer&quot;</span>);</span><br><span class="line">  retrans_timer-&gt;timeout = TCP_RETRANS_INTERVAL_INITIAL;</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_unset_retrans_timer</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">retrans_timer</span> =</span> &amp;tsk-&gt;retrans_timer;</span><br><span class="line">  assert(retrans_timer-&gt;type == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (retrans_timer-&gt;enable == <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;unset retrans timer&quot;</span>);</span><br><span class="line">  retrans_timer-&gt;enable = <span class="number">0</span>;</span><br><span class="line">  list_delete_entry(&amp;retrans_timer-&gt;<span class="built_in">list</span>);</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这几个函数还是比较好理解的。这里我做了一个处理是，如果一个重传定时器处于启用状态，那么就将其放在计时器列表里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_scan_timer_list</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_timer</span> *<span class="title">pos</span>, *<span class="title">q</span>;</span></span><br><span class="line">  <span class="comment">// iterate over the timer_list</span></span><br><span class="line">  pthread_mutex_lock(&amp;timer_lock);</span><br><span class="line">  list_for_each_entry_safe(pos, q, &amp;timer_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos-&gt;type == <span class="number">0</span>)</span><br><span class="line">      handle_timewait_timer(pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos-&gt;type == <span class="number">1</span>) &#123;</span><br><span class="line">      assert(pos-&gt;enable == <span class="number">1</span>);</span><br><span class="line">      handle_retrans_timer(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">log</span>(ERROR, <span class="string">&quot;Unknown timer type %d&quot;</span>, pos-&gt;type);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;timer_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来是处理重传定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">handle_retrans_timeout</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;retrans timeout&quot;</span>);</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;send_lock);</span><br><span class="line">  <span class="comment">// popping out the packets of which seq_end &lt;= snd_una</span></span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;current snd_una: %d&quot;</span>, tsk-&gt;snd_una);</span><br><span class="line">  <span class="keyword">while</span> (!list_empty(&amp;tsk-&gt;send_buf)) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pending_packet</span> *<span class="title">pos</span> =</span></span><br><span class="line">        list_entry(tsk-&gt;send_buf.next, <span class="keyword">struct</span> pending_packet, <span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (less_or_equal_32b(pos-&gt;seq_end, tsk-&gt;snd_una)) &#123;</span><br><span class="line">      list_delete_entry(&amp;pos-&gt;<span class="built_in">list</span>);</span><br><span class="line">      <span class="built_in">free</span>(pos-&gt;packet);</span><br><span class="line">      <span class="built_in">free</span>(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list_empty(&amp;tsk-&gt;send_buf)) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;tsk-&gt;send_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// run through the send buffer, and retransmit all the packets in it</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pending_packet</span> *<span class="title">pos</span> =</span></span><br><span class="line">      list_entry(tsk-&gt;send_buf.next, <span class="keyword">struct</span> pending_packet, <span class="built_in">list</span>);</span><br><span class="line">  <span class="type">char</span> *packet = pos-&gt;packet;</span><br><span class="line">  <span class="keyword">if</span> (pos-&gt;retrans_times &gt; TCP_MAX_RETRANS) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;max retrans times reached, terminate connection&quot;</span>);</span><br><span class="line">    tcp_terminate(tsk);</span><br><span class="line">    pthread_mutex_unlock(&amp;tsk-&gt;send_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pos-&gt;retrans_times++;</span><br><span class="line">  tsk-&gt;retrans_timer.timeout = TCP_RETRANS_INTERVAL_INITIAL</span><br><span class="line">                               &lt;&lt; pos-&gt;retrans_times;</span><br><span class="line">  <span class="type">int</span> packet_len =</span><br><span class="line">      pos-&gt;len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">  assert(less_than_32b(tsk-&gt;snd_una, pos-&gt;seq_end));</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;retrans packet, seq: %d, seq_end: %d&quot;</span>, pos-&gt;seq, pos-&gt;seq_end);</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;retrans timeout is now set to %d&quot;</span>, tsk-&gt;retrans_timer.timeout);</span><br><span class="line">  <span class="comment">// note that we should not call ip_send_packet here because it will free the packet</span></span><br><span class="line">  pos-&gt;packet = move_and_ip_send_packet(packet, packet_len);</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;send_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先为了保险起见，依然是把<code>ack</code>掉的包从发送缓存中删除。然后是重传的逻辑，如果重传次数太多就直接断开连接，否则就重传。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="title function_">move_and_ip_send_packet</span><span class="params">(<span class="type">char</span>* packet, <span class="type">int</span> packet_len)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* moved_packet = (<span class="type">char</span>*)<span class="built_in">malloc</span>(packet_len);</span><br><span class="line">  assert(moved_packet != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(moved_packet, packet, packet_len);</span><br><span class="line">  ip_send_packet(packet, packet_len);</span><br><span class="line">  <span class="keyword">return</span> moved_packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为ip_send_packet会释放掉packet，所以我们还是需要先拷贝一份，在此之后原来的packet就不可再使用，这很像<code>std::move</code>，即所谓的移动语义，因此函数名是<code>move_and_ip_send_packet</code>。</p>
<h2 id="text4-pits-and-falls"><a class="markdownIt-Anchor" href="#text4-pits-and-falls"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>4. Pits and Falls</mtext></mrow><annotation encoding="application/x-tex">\text{4. Pits and Falls}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">4. Pits and Falls</span></span></span></span></span></h2>
<p>一如既往的，这次实验踩的坑也不少。</p>
<ol>
<li>
<p>同样的，还是要比较次数时的比较带不带等号，我因为多了一次比较导致一遇到丢包就会多等一次重传，严重损害了性能。</p>
</li>
<li>
<p>删除定时器的时候一定要明确自己删除的目标，不要误删。</p>
</li>
<li>
<p>本次实验涉及到的锁很多，注意锁的顺序，不要死锁。</p>
</li>
</ol>
<p>然而，即便如此，本次实验我的实现依然还是有些问题，首先是对于连接建立和断开时的丢包，我没有处理好，由于自己之前建立起来的框架并未考虑丢包的问题，要新加入这方面的逻辑变得不容易。其次是如果输出调试信息到控制台，则会导致整个连接运行一段时间后彻底停下。这里真的非常感谢助教，愿意不辞辛苦也不计安全性地让我直接上服务器调试（当然没调出问题）最后还亲自帮我看脚本，帮助我定位了问题所在。</p>
<p>后来老师点出来，这还是由于整个程序没有做到并发安全导致的，因为输出到控制台是一个非常耗时的操作，有可能导致线程之间的冲突，相比之下，无论是不输出调试信息还是输出到文件都不会这么耗时，所以这个问题也就不会出现。</p>
<p>不过，我最后还是没有发现问题在哪儿。。。</p>
<h2 id="text5-summary"><a class="markdownIt-Anchor" href="#text5-summary"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>5. Summary</mtext></mrow><annotation encoding="application/x-tex">\text{5. Summary}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">5. Summary</span></span></span></span></span></h2>
<p>本次实验给之前的基础上加上了丢包处理，使得整个协议栈更加完善，通过三个部件，即重传定时器，发送包队列和乱序包缓冲的配合，实现了发送方对于丢包重传的处理，以及接收方对于到达数据包乱序的处理，从而实现了可靠的传输。</p>
<p>但是现在的实现只能说在大部分情况下不会出现问题，在一些特殊情况下还是会出现问题，比如连接建立和断开时的丢包，比如输出到控制台的问题。只能说，希望后续还会有时间重新审视这份代码，找出问题所在。</p>
<h1 id="textlab-3-拥塞控制"><a class="markdownIt-Anchor" href="#textlab-3-拥塞控制"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Lab-3. 拥塞控制</mtext></mrow><annotation encoding="application/x-tex">\text{Lab-3. 拥塞控制}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Lab-3. </span><span class="mord cjk_fallback">拥塞控制</span></span></span></span></span></h1>
<p>在实际网络中，我们并不知道整个网络的情况，如果一味地发送数据包，很可能会加剧网络拥塞，所以我们需要实现拥塞控制机制，评估网络状态，并且控制发送窗口，使得发送的数据包数量不会超过网络的承载能力。</p>
<h2 id="text1-reno-newreno"><a class="markdownIt-Anchor" href="#text1-reno-newreno"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>1. Reno &amp; NewReno</mtext></mrow><annotation encoding="application/x-tex">\text{1. Reno \&amp; NewReno}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">1. Reno &amp; NewReno</span></span></span></span></span></h2>
<p>本次实验实现的是<code>NewReno</code>拥塞控制算法，这是一种比较经典的拥塞控制算法，要理解<code>NewReno</code>中的<code>New</code>，我首先查找资料，了解了其前身<code>Reno</code>算法~~（其实一部分原因是PPT实在看不懂）~~。</p>
<p><code>Reno</code>算法主要分为三个状态：<code>Slow Start</code>，<code>Congestion Avoidance</code>和<code>Fast Recovery</code>。其状态转换关系如下：</p>
<p><img src="/.com//reno.png" alt="reno"></p>
<p><code>NewReno</code>算法对<code>Reno</code>算法进行了改进，在所谓的快速重传阶段，<code>Reno</code>算法只会重传一个丢失的包，而<code>NewReno</code>算法会重传所有连续的丢失的包。</p>
<h2 id="text2-implementation"><a class="markdownIt-Anchor" href="#text2-implementation"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>2. Implementation</mtext></mrow><annotation encoding="application/x-tex">\text{2. Implementation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">2. Implementation</span></span></span></span></span></h2>
<p>接下来是实现。这个实验是我在TCP三个实验中耗时最长的一个，因为自己怎么也没读懂PPT，所以又去搜集了其他资料对照，但是即使是其他资料，说法也不统一。。。而且为了加入拥塞控制，对原来的代码进行了很多的改动。中间有一次以为自己做对了，写报告的时候把结果图拿来对比PPT发现还有问题，又改了好几天。</p>
<p>首先考虑到拥塞控制整体是一个较为独立的模块，我将其全部封装进了一个类当中，有自己的状态转移和处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_controller</span> &#123;</span></span><br><span class="line">  <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">tcp_cc_state</span> <span class="title">state</span>;</span></span><br><span class="line">  u32 ssthresh;</span><br><span class="line">  u32 cwnd;</span><br><span class="line">  u32 rp; <span class="comment">// recovery point</span></span><br><span class="line">  u8 dup_cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个字段的含义都还算比较直观吧，接下来我对于原有的基础进行了改造。</p>
<p>首先是改造后的处理<code>ack</code>包的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">inflight</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (tsk-&gt;snd_nxt - tsk-&gt;snd_una) / TCP_MSS - tsk-&gt;cc.dup_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ack_packet</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, <span class="keyword">struct</span> tcp_cb *cb, <span class="type">char</span> *packet)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data = packet + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;ack data packet, seq %d, ack: %d&quot;</span>, cb-&gt;seq, cb-&gt;ack);</span><br><span class="line">  <span class="type">int</span> data_len = cb-&gt;pl_len;</span><br><span class="line">  <span class="comment">// handle the case of ack in different state</span></span><br><span class="line">  <span class="keyword">switch</span> (tsk-&gt;state) &#123;</span><br><span class="line">  <span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_set_state(tsk, TCP_ESTABLISHED);</span><br><span class="line">    tcp_hash(tsk);</span><br><span class="line">    <span class="comment">// add to the accept queue of parent socket</span></span><br><span class="line">    tcp_sock_accept_enqueue(tsk);</span><br><span class="line">    wake_up(tsk-&gt;parent-&gt;wait_accept);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_FIN_WAIT_1:</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    tcp_set_state(tsk, TCP_FIN_WAIT_2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">    tcp_set_state(tsk, TCP_TIME_WAIT);</span><br><span class="line">    tcp_set_timewait_timer(tsk);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">    tcp_set_state(tsk, TCP_CLOSED);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> old_no_allowed = tsk-&gt;no_allowed_to_send;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;ack: %d, snd_una: %d&quot;</span>, cb-&gt;ack, tsk-&gt;snd_una);</span><br><span class="line">  <span class="keyword">if</span> (cb-&gt;ack &lt;= tsk-&gt;snd_una) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;received duplicate ack, handle it&quot;</span>);</span><br><span class="line">    tcp_cc_handle_dup_ack(tsk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;received new ack, handle it&quot;</span>);</span><br><span class="line">	tcp_cc_handle_new_ack(tsk, cb);</span><br><span class="line">  &#125;</span><br><span class="line">  tcp_update_window_safe(tsk, cb);</span><br><span class="line">  <span class="type">int</span> send_able = tsk-&gt;snd_wnd / TCP_MSS - inflight(tsk);</span><br><span class="line">  <span class="type">int</span> packet_allowed_to_send = max(send_able, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (packet_allowed_to_send &gt; <span class="number">0</span> &amp;&amp; old_no_allowed) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;allowed to send, wake up sending&quot;</span>);</span><br><span class="line">    tsk-&gt;no_allowed_to_send = <span class="literal">false</span>;</span><br><span class="line">    wake_up(tsk-&gt;wait_send);</span><br><span class="line">  &#125;</span><br><span class="line">  tcp_try_update_retrans_timer(tsk);</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;snd_una == tsk-&gt;snd_nxt) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;all acked, unset retrans timer&quot;</span>);</span><br><span class="line">    tcp_unset_retrans_timer(tsk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> offset = tsk-&gt;rcv_nxt - cb-&gt;seq;</span><br><span class="line">  data_len -= offset;</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;write data to rcv_buf, offset: %d, data_len: %d&quot;</span>, offset,</span><br><span class="line">        data_len);</span><br><span class="line">    <span class="type">bool</span> old_empty = ring_buffer_empty(tsk-&gt;rcv_buf);</span><br><span class="line">    write_ring_buffer(tsk-&gt;rcv_buf, data + offset, data_len);</span><br><span class="line">    tsk-&gt;rcv_wnd = ring_buffer_free(tsk-&gt;rcv_buf);</span><br><span class="line">    tsk-&gt;rcv_nxt = cb-&gt;seq_end;</span><br><span class="line">    <span class="keyword">if</span> (old_empty &amp;&amp; !ring_buffer_empty(tsk-&gt;rcv_buf)) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;buffer is not empty, wake up receiving&quot;</span>);</span><br><span class="line">      wake_up(tsk-&gt;wait_recv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;write data to rcv_buf succeeded, rcv_wnd: %d&quot;</span>, tsk-&gt;rcv_wnd);</span><br><span class="line">    pthread_mutex_unlock(&amp;tsk-&gt;rcv_buf-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_handle_ack</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, <span class="keyword">struct</span> tcp_cb *cb,</span></span><br><span class="line"><span class="params">                           <span class="type">char</span> *packet)</span> &#123;</span><br><span class="line">  assert(cb-&gt;flags &amp; TCP_ACK);</span><br><span class="line">  update_send_buffer(tsk, cb);</span><br><span class="line">  <span class="keyword">if</span> (!is_tcp_seq_valid(tsk, cb)) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;received packet with invalid seq, drop it.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;receive seq: %d, current expected rcv_nxt: %d&quot;</span>, cb-&gt;seq,</span><br><span class="line">      tsk-&gt;rcv_nxt);</span><br><span class="line">  <span class="keyword">if</span> (less_than_32b(cb-&gt;seq, tsk-&gt;rcv_nxt) &amp;&amp;</span><br><span class="line">      less_or_equal_32b(cb-&gt;seq_end, tsk-&gt;rcv_nxt)) &#123;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;receive outdated packet, send ack.&quot;</span>);</span><br><span class="line">    tcp_cc_handle_dup_ack(tsk);</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (less_or_equal_32b(cb-&gt;seq, tsk-&gt;rcv_nxt)) &#123;</span><br><span class="line">    ack_packet(tsk, cb, packet);</span><br><span class="line">    ack_ofo_packets(tsk);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pend_ofo_packet(tsk, cb, packet);</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;receive out-of-order packet, send ack.&quot;</span>);</span><br><span class="line">    tcp_send_control_packet(tsk, TCP_ACK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本上就是把状态转移的逻辑给抽出来了。同时，相比于最开始的基础协议栈，不能发送包的条件变多了，因此我专门加了一个<code>no_allowed_to_send</code>的标志位，用于标记当前是否可以发送包，当任意一个导致不能发送包的条件被破坏时，都尝试唤醒发送方。</p>
<p>除此以外，我们也需要对到来的<code>ack</code>包进行区分了，如果当前收到的包<code>seq_end</code>不超过<code>snd_una</code>，表明发送方收到了一个重复的<code>ack</code>，此时就需要进入拥塞控制针对重复<code>ack</code>的处理，反之则是新<code>ack</code>的处理。</p>
<p>在确认新的包的时候，我们需要计算当前是否还能够发送包，这需要以窗口大小减去在途的包的数量，如果可以发送，但是原来不能，那么就需要唤醒发送方。</p>
<p>其他的基本上比较大同小异。接下来就是拥塞控制中针对<code>ack</code>包的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_cc_handle_new_ack</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk, <span class="keyword">struct</span> tcp_cb *cb)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">  tsk-&gt;cc.dup_cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (tsk-&gt;cc.state) &#123;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_SLOW_START:</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;cc.cwnd &lt;= tsk-&gt;cc.ssthresh) &#123;</span><br><span class="line">      tsk-&gt;cc.cwnd &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      report(tsk-&gt;cc.cwnd);</span><br><span class="line">	  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tsk-&gt;cc.state = TCP_CC_CONGESTION_AVOIDANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_CONGESTION_AVOIDANCE:</span><br><span class="line">    tsk-&gt;cc.cwnd += TCP_MSS * TCP_MSS / tsk-&gt;cc.cwnd;</span><br><span class="line">    report(tsk-&gt;cc.cwnd);</span><br><span class="line">	<span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_FAST_RECOVERY:</span><br><span class="line">    tsk-&gt;cc.cwnd = tsk-&gt;cc.ssthresh;</span><br><span class="line">    tsk-&gt;cc.state = TCP_CC_CONGESTION_AVOIDANCE;</span><br><span class="line">    report(tsk-&gt;cc.cwnd);</span><br><span class="line">	  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;unknown cc state&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_cc_handle_dup_ack</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">  tsk-&gt;cc.dup_cnt++;</span><br><span class="line">  <span class="built_in">log</span>(DEBUG, <span class="string">&quot;handle dup ack, current dup_cnt: %d&quot;</span>, tsk-&gt;cc.dup_cnt);</span><br><span class="line">  <span class="keyword">switch</span> (tsk-&gt;cc.state) &#123;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_SLOW_START:</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;cc.dup_cnt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;dup ack == 3, fast retransmit&quot;</span>);</span><br><span class="line">	  tsk-&gt;cc.rp = tsk-&gt;snd_nxt;</span><br><span class="line">	  tsk-&gt;cc.state = TCP_CC_FAST_RECOVERY;</span><br><span class="line">      tcp_fast_retransmit(tsk);</span><br><span class="line">      tsk-&gt;cc.cwnd = tsk-&gt;cc.ssthresh + <span class="number">3</span> * TCP_MSS;</span><br><span class="line">    &#125;</span><br><span class="line">    report(tsk-&gt;cc.cwnd);</span><br><span class="line">	<span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_CONGESTION_AVOIDANCE:</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;cc.dup_cnt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">log</span>(DEBUG, <span class="string">&quot;dup ack == 3, fast retransmit&quot;</span>);</span><br><span class="line">      tsk-&gt;cc.rp = tsk-&gt;snd_nxt;</span><br><span class="line">      tcp_fast_retransmit(tsk);</span><br><span class="line">      tsk-&gt;cc.state = TCP_CC_FAST_RECOVERY;</span><br><span class="line">	  tsk-&gt;cc.cwnd = tsk-&gt;cc.ssthresh + <span class="number">3</span> * TCP_MSS;</span><br><span class="line">    &#125;</span><br><span class="line">    report(tsk-&gt;cc.cwnd);</span><br><span class="line">	<span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TCP_CC_FAST_RECOVERY:</span><br><span class="line">    tsk-&gt;cc.cwnd += TCP_MSS;</span><br><span class="line">    report(tsk-&gt;cc.cwnd);</span><br><span class="line">	<span class="built_in">log</span>(DEBUG, <span class="string">&quot;cwnd: %d&quot;</span>, tsk-&gt;cc.cwnd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">log</span>(ERROR, <span class="string">&quot;unknown cc state&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我并不是完全对着那张图写的，在<code>TCP_CC_SLOW_START</code>阶段我是直接翻倍的。</p>
<p>关于收到<code>new ack</code>，我们可以简单地理解为，最终一定会停留在拥塞控制阶段，其中设计的思路也很简单，<code>new ack</code>是网络环境正常的一个标识，<code>new ack</code>连续到达，就表明网络环境较为通畅，可以适当增大拥塞窗口，然而这个过程一定是有节制的，不然随着窗口越来越大，发送的包也会越来越多，影响网络的稳定性。因此无论从哪个阶段开始，收<code>new ack</code>最终都会进入<code>CONGESTION_AVOIDANCE</code>阶段。</p>
<p>对于<code>dup ack</code>的处理略微有些复杂，这里也涉及到了快速重传。快速重传是<code>NewReno</code>和<code>Reno</code>的一个重大区别，<code>Reno</code>在重传时只会重新传一个包，而<code>NewReno</code>则不然，它会一直重传至所谓的“恢复点”，这是在进入<code>FAST RECOVERY</code>阶段之前的<code>snd_nxt</code>值。我们可以简单理解为：进入<code>FAST RECOVERY</code>阶段时我们已经收到了一定数量的重复包，怀疑发送窗口中的包已经丢掉了，快速重传也就是重传这些包。这么做的理由在于，如果我们重复性地收到对方发来的已经过时的<code>ack</code>，那么我们就可以推测对方能收到我们的包，但是很可能由于发生了丢包，导致无法确认我们的包。这时，<br>
为了提高性能，我们不必等到超时再重传，而是可以直接重传这些包。</p>
<p>快速重传的函数长这样，它只是改了一下窗口和慢启动阈值，实际的重传要自己完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_fast_retransmit</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  tsk-&gt;cc.ssthresh = tsk-&gt;cc.cwnd &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (tsk-&gt;snd_una &gt;= tsk-&gt;cc.rp) &#123;</span><br><span class="line">	<span class="built_in">log</span>(DEBUG, <span class="string">&quot;no packet to fast retransmit&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;send_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pending_packet</span> *<span class="title">pos</span>, *<span class="title">q</span>;</span></span><br><span class="line">  list_for_each_entry_safe(pos, q, &amp;tsk-&gt;send_buf, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less_than_32b(pos-&gt;seq_end, tsk-&gt;cc.rp))</span><br><span class="line">      retrans_pending_packet(tsk, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;send_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来是处理超时重传时的拥塞控制机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_cc_handle_rto</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tsk)</span> &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">  tsk-&gt;cc.dup_cnt = <span class="number">0</span>;</span><br><span class="line">  tsk-&gt;cc.ssthresh = tsk-&gt;cc.cwnd &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  tsk-&gt;cc.cwnd = TCP_MSS;</span><br><span class="line">  <span class="comment">// all packets between snd_una and snd_nxt are considered lost</span></span><br><span class="line">  tsk-&gt;cc.loss_cnt += (tsk-&gt;snd_nxt - tsk-&gt;snd_una) / TCP_MSS;</span><br><span class="line">  tsk-&gt;cc.state = TCP_CC_SLOW_START;</span><br><span class="line">  report(tsk-&gt;cc.cwnd);</span><br><span class="line">  pthread_mutex_unlock(&amp;tsk-&gt;cc.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在不同状态下，对于超时重传，我们都会回到<code>SLOW START</code>阶段，并且重置<code>cwnd</code>，可以简单理解为超时重传表明网络环境不太好，我们需要重新评估网络环境，所以回到<code>SLOW START</code>阶段，重新开始。</p>
<p>此外，<code>tcp_sock_write</code>我也做了一个比较大的修改，使之适应拥塞控制机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sock_write</span><span class="params">(<span class="keyword">struct</span> tcp_sock* tsk, <span class="type">char</span>* buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sent_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (sent_len &lt; len) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((tsk-&gt;snd_wnd == <span class="number">0</span> || tsk-&gt;no_allowed_to_send) &amp;&amp; tsk-&gt;state == TCP_ESTABLISHED) &#123;</span><br><span class="line">      sleep_on(tsk-&gt;wait_send);</span><br><span class="line">      <span class="keyword">if</span> (tsk-&gt;state == TCP_CLOSED) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> packets_allowed_to_send = tsk-&gt;snd_wnd / TCP_MSS - inflight(tsk);</span><br><span class="line">    <span class="keyword">if</span> (packets_allowed_to_send &lt; <span class="number">0</span>) packets_allowed_to_send = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">log</span>(DEBUG, <span class="string">&quot;sending window: %d, inflight: %d, packets allowed to send: %d&quot;</span>,</span><br><span class="line">        tsk-&gt;snd_wnd, inflight(tsk), packets_allowed_to_send);</span><br><span class="line">    <span class="keyword">if</span> (packets_allowed_to_send == <span class="number">0</span>) &#123;</span><br><span class="line">      tsk-&gt;no_allowed_to_send = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> send_len = min(tsk-&gt;snd_una + tsk-&gt;snd_wnd - tsk-&gt;snd_nxt, len - sent_len);</span><br><span class="line">	<span class="keyword">while</span> (!send_len &amp;&amp; tsk-&gt;state == TCP_ESTABLISHED) &#123;</span><br><span class="line">		sleep_on(tsk-&gt;wait_send);</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;state == TCP_CLOSED) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		send_len = min(tsk-&gt;snd_una + tsk-&gt;snd_wnd - tsk-&gt;snd_nxt, len - sent_len);</span><br><span class="line">		<span class="keyword">if</span> (len == sent_len) <span class="keyword">return</span> sent_len;</span><br><span class="line">	&#125;</span><br><span class="line">    send_len = min(</span><br><span class="line">        send_len, <span class="number">1514</span> - ETHER_HDR_SIZE - IP_BASE_HDR_SIZE - TCP_BASE_HDR_SIZE);</span><br><span class="line">    <span class="type">char</span>* packet_buf = <span class="built_in">malloc</span>(send_len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE +</span><br><span class="line">                              TCP_BASE_HDR_SIZE);</span><br><span class="line">    <span class="type">char</span>* data =</span><br><span class="line">        packet_buf + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, buf + sent_len, send_len);</span><br><span class="line">    tcp_send_packet(</span><br><span class="line">        tsk, packet_buf,</span><br><span class="line">        send_len + ETHER_HDR_SIZE + IP_BASE_HDR_SIZE + TCP_BASE_HDR_SIZE, <span class="literal">true</span>);</span><br><span class="line">    sent_len += send_len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的就是如前所说，发送包的条件变苛刻了，一旦发现我们不能发送包，就要睡觉，等待制约条件被破坏后被唤醒，继续发送。</p>
<p>在前面的代码中，频繁出现<code>report</code>函数，该函数将当前的时间，以及<code>cwnd</code>的值输出到文件，便于后续数据分析。</p>
<p>当然也就少不了绘制图的脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_cwnd</span>(<span class="params">file_path</span>):</span><br><span class="line">    times = []</span><br><span class="line">    cwnd_sizes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            time, cwnd = <span class="built_in">map</span>(<span class="built_in">float</span>, line.split())</span><br><span class="line">            times.append(time)</span><br><span class="line">            cwnd_sizes.append(<span class="built_in">int</span>(cwnd))</span><br><span class="line"></span><br><span class="line">    plt.plot(times, cwnd_sizes)</span><br><span class="line">    plt.title(<span class="string">&#x27;CWND Sizes Over Time&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Time&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;CWND Size&#x27;</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;./cwnd.txt&#x27;</span></span><br><span class="line">plot_cwnd(file_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="text3-pits-and-falls"><a class="markdownIt-Anchor" href="#text3-pits-and-falls"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>3. Pits and Falls</mtext></mrow><annotation encoding="application/x-tex">\text{3. Pits and Falls}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">3. Pits and Falls</span></span></span></span></span></h2>
<p>这次实验踩的坑也不少了。</p>
<ol>
<li>
<p>处理<code>dup_ack</code>里的判断<code>dup_cnt</code>的条件，应该是写等于号，而非大于等于号，如果是大于等于号，在接收到第三个<code>dup_ack</code>后，后续的每个<code>dup_ack</code>都会导致一次快速重传！这无疑会让本来就不稳定的网络雪上加霜。</p>
</li>
<li>
<p>由于要根据<code>snd_una</code>和<code>seq_end</code>来判断是否是重复的<code>ack</code>，这里的判断在“是否能取等”上面需要尤其小心边界问题，多一个等号可能就会误判所有的<code>ack</code>。</p>
</li>
<li>
<p>由于发送方睡眠的可能性更多了，也要仔细注意所有可能需要唤醒发送方的位置，考虑好发送方的睡眠是由哪些变量决定的，在所有这些变量更新的地方都需要注意判断一下是否需要唤醒发送方。这个处理不好可能发送方就一睡不醒了。</p>
</li>
</ol>
<h2 id="text4-result"><a class="markdownIt-Anchor" href="#text4-result"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>4. Result</mtext></mrow><annotation encoding="application/x-tex">\text{4. Result}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">4. Result</span></span></span></span></span></h2>
<p>根据输出结果绘制如下：</p>
<p><img src="/.com//cwnd.png" alt="cwnd"></p>
<p>感觉大体趋势是很像的，最开始网络环境较好，<code>cwnd</code>迅速增大，然后在超过阈值之后变为线性增长，不过这里由于时间太短不太看得出来，同时由于我们发了太多的包，网络环境也变得有些拥塞了，所以后面就收到了几个重复的<code>ack</code>，导致窗口迅速减半，此后就是一直处于波动。中间也会有丢包，导致整个窗口变为初始值并且一段时间内发不了任何包，只能等待重传，以及收到对方的<code>ack</code>。</p>
<h2 id="text5-summary-2"><a class="markdownIt-Anchor" href="#text5-summary-2"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>5. Summary</mtext></mrow><annotation encoding="application/x-tex">\text{5. Summary}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">5. Summary</span></span></span></span></span></h2>
<p>本次实验基本上实现了<code>NewReno</code>拥塞控制算法，其原理是一个简单的状态机，根据网络环境中发生的不同事件切换不同的状态，评估网络环境并且作出相应的调整。</p>
<p>具体而言，其分为三个状态：<code>SLOW START</code>，<code>CONGESTION AVOIDANCE</code>和<code>FAST RECOVERY</code>。<code>SLOW START</code>阶段是指在网络环境较好时，我们可以快速增大发送窗口，以便更快地发送数据。<code>CONGESTION AVOIDANCE</code>阶段是指在网络环境较差时，我们需要缓慢增大发送窗口，以便更好地适应网络环境。<code>FAST RECOVERY</code>阶段是指在发生丢包时，我们可以快速重传，以便更快地恢复丢失的包。这也就是“慢启动，快重传”这几个词的来源，某种程度是，也回应了之前的<code>bufferfloat</code>实验。</p>
<h1 id="text4-summary-for-tcp"><a class="markdownIt-Anchor" href="#text4-summary-for-tcp"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>4. Summary for TCP</mtext></mrow><annotation encoding="application/x-tex">\text{4. Summary for TCP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">4. Summary for TCP</span></span></span></span></span></h1>
<p>终于结束了整个网络实验中最让我期待的部分，然而这部分的难度也是相当之大，中间也是因为自己的一些理解上的错误，心态上的问题，实现上的粗糙，耽误了很多时间。但是再怎么粗糙，一个简陋的网络协议栈也终于就此搭起来了。</p>
<p>这三次实验层层递进，中间一个小细节给了我很深刻的印象，在做第一个基础实验的时候，我由于对发送方的发送毫无控制，直接导致了<code>bufferfloat</code>现象，出现了丢包，让接收方无法再接收任何数据，因此不得不让发送方休眠一会儿。而在实现了可靠传输之后，即使我去掉了这个睡眠，让发送方不停发送，接收方也能正常收到数据，但是仍然需要接受非常多的乱序包之后才能做出回应。而在终于实现了拥塞控制的快重传机制之后，双方回应丢包的速度就快多了。我原本以为加入拥塞控制以后传输会变得更慢，但是没想到由于双方对于丢包现象的快速响应，传输的时间没怎么变长，反而缩短了。这也给了我很大的成就感。</p>
<p>这三次实验也让我对于整个网络协议栈的结构有了更深的理解，至此，我基本上也初步理解了“网络是如何构建的”这个从应用贯穿到底层的问题。从这一点上讲，虽然这三次实验消耗很大，但是收获是值得的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Network/" rel="tag"># Network</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/31/VPT-Recap/" rel="prev" title="A Recap on Volumetric Path Tracing">
                  <i class="fa fa-chevron-left"></i> A Recap on Volumetric Path Tracing
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/28/UCAS-Network-Lab-6-router/" rel="next" title="UCAS-Network-Lab-6-Router">
                  UCAS-Network-Lab-6-Router <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CLV</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.3/katex.min.css" integrity="sha256-NJNVfEC6jfEt62wQMafLNT2eI6BaWONXbpkSEVAs3+8=" crossorigin="anonymous">



</body>
</html>
